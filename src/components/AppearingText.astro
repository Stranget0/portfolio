---
type TextData = [number, string, number][];
interface Props {
	text: TextData;
}
const { text } = Astro.props;
---

<script>
	import createEventSequence from "@utils/sequencedEvents";

	const stages = document.querySelectorAll<HTMLElement>(".appearing-stage");

	play(stages[0]);

	function hasEndOfSentence(text: string) {
		return /[.!?$]/.test(text);
	}

	function play(stage: HTMLElement) {
		const word = stage.children.item(0) as HTMLElement;
		let firstVisibleWord: HTMLElement | null = null;
		let lastVisibleWord: HTMLElement | null = null;
		let lastFinishedTransitionWord: HTMLElement | null = null;
		stage.classList.add("playing");
		stage.classList.remove("has-finished-words");

		if (word) {
			setTimeout(() => {
				setFirstVisibleWord(word);
				playWord(word);
			}, 250);
		}
		function setter(
			currentValue: HTMLElement | null,
			word: HTMLElement | null,
			classToAdd: string,
			classToRemove = classToAdd
		) {
			if (currentValue === word) return word;
			currentValue?.classList.remove(classToRemove);
			word?.classList.add(classToAdd);
			return word;
		}

		function setFirstVisibleWord(word: typeof firstVisibleWord) {
			firstVisibleWord = setter(firstVisibleWord, word, "word-first-visible");
		}

		function setLastVisibleWord(word: typeof lastVisibleWord) {
			lastVisibleWord = setter(lastVisibleWord, word, "word-last-visible");
		}
		function setLastFinishedTransitionWord(
			word: typeof lastFinishedTransitionWord
		) {
			lastFinishedTransitionWord = setter(
				lastFinishedTransitionWord,
				word,
				"last-finished-transition"
			);
			stage.classList.add("has-finished-words");
		}

		function showWord(word: HTMLElement | null, delay?: number) {
			if (lastVisibleWord) {
				lastVisibleWord.style.transitionDelay = "";
			}
			setLastVisibleWord(word);
			if (word) {
				word.style.display = "";
				word.style.transitionDelay = delay ? delay + "ms" : "";
			}
		}

		function playWord(word: HTMLElement) {
			showWord(word);
			const isEndOfSentence = hasEndOfSentence(word.textContent || "");
			const nextWord = word.nextElementSibling as HTMLElement | null;
			const wordDuration = getWordDuration(word);
			const appearDuration = isEndOfSentence
				? wordDuration * 0.6
				: wordDuration;
			const hideDuration = isEndOfSentence ? wordDuration * 0.4 : 0;

			const controls = createEventSequence().wait(appearDuration, () => {
				if (nextWord) playWord(nextWord);
				if (isEndOfSentence) {
					showWord(nextWord, hideDuration);
					setFirstVisibleWord(nextWord);
				}
			});
			if (hideDuration) {
				controls.wait(hideDuration, () => {
					setLastFinishedTransitionWord(word);
				});
			}
			controls.run();
		}
	}
	function getWordDuration(word: HTMLElement): number {
		return parseFloat(word.dataset.wordDuration || "0");
	}
</script>

<p class="appearing-stage" prose text-lg font-extralight leading-7>
	{
		text.map(([wordDuration, word]) => {
			return (
				<span
					class="appearing-word 
					motion-safe:transition-opacity motion-safe:duration-500"
					data-word-duration={wordDuration}
				>
					{word}
				</span>
			);
		})
	}
</p>
<style lang="scss">
	.appearing-stage.playing {
		.appearing-word {
			opacity: 0;

			&.word-first-visible,
			&.word-first-visible ~ .appearing-word {
				opacity: 1;
			}
			&.last-finished-transition ~ .appearing-word {
				display: inline;
			}
			&.word-last-visible ~ .appearing-word {
				opacity: 0;
				& + .appearing-word {
					display: none;
				}
			}
		}
		&.has-finished-words .appearing-word {
			display: none;
		}
	}
</style>
