---
/* eslint-disable astro/no-unused-css-selector */
// Disable eslint for css selectors, as some selectors are used in other components

type TextData = [number, string, number][];
interface Props {
	text: TextData;
}
const { text } = Astro.props;
---

<script>
	const stages = document.querySelectorAll<HTMLElement>(".appearing-stage");

	play(stages[0]);

	function hasEndOfSentence(text: string) {
		return /[.!?$]/.test(text);
	}

	function play(stage: HTMLElement) {
		const start = Date.now();

		let acc = 0;
		for (const word of stage.children) {
			(word as HTMLElement).dataset.startTime = `${start + acc}`;
			acc += getWordDuration(word as HTMLElement);
		}

		const word = stage.children.item(0) as HTMLElement;
		let lastVisibleWord: HTMLElement | null = null;
		let hideBeforeWord: HTMLElement | null = null;
		let lastFinishedTransitionWord: HTMLElement | null = null;
		stage.classList.add("playing");
		stage.classList.remove("has-finished-words");
		stage.classList.remove("has-fading-words");
		playWord(word);

		function setter(
			currentValue: HTMLElement | null,
			word: HTMLElement | null,
			classToAdd: string,
			classToRemove = classToAdd
		) {
			if (currentValue === word) return word;
			currentValue?.classList.remove(classToRemove);
			word?.classList.add(classToAdd);
			return word;
		}

		function setLastVisibleWord(word: typeof lastVisibleWord) {
			lastVisibleWord = setter(lastVisibleWord, word, "word-last-visible");
		}
		function setHideBeforeWord(word: typeof hideBeforeWord) {
			hideBeforeWord = setter(hideBeforeWord, word, "word-hide-before");
		}
		function setLastFinishedTransitionWord(
			word: typeof lastFinishedTransitionWord
		) {
			stage.classList.add("has-fading-words");
			lastFinishedTransitionWord = setter(
				lastFinishedTransitionWord,
				word,
				"last-finished-transition"
			);
			stage.classList.add("has-finished-words");
		}

		function showWord(word: HTMLElement | null, delay?: number) {
			setLastVisibleWord(word);
		}

		function playWord(
			word: HTMLElement,
			lastWord: HTMLElement | null = null,
			isNewSentence?: boolean
		) {
			showWord(word);
			if (isNewSentence) setLastFinishedTransitionWord(lastWord);
			const isEndOfSentence = hasEndOfSentence(word.textContent || "");
			const nextWord = word.nextElementSibling as HTMLElement | null;

			const nextWordStamp = parseInt(nextWord?.dataset.startTime || "0");
			const timeToNextWord1 = nextWordStamp - Date.now();

			if (nextWord) {
				setTimeout(() => {
					playWord(nextWord, word, isEndOfSentence);
				}, timeToNextWord1);
			}
			if (isEndOfSentence) {
				setTimeout(() => {
					setHideBeforeWord(nextWord);
				}, timeToNextWord1 - 500);
			}
		}
	}

	function getWordDuration(word: HTMLElement): number {
		return parseFloat(word.dataset.wordDuration || "0");
	}
</script>

<p class="appearing-stage text-body prose">
	{
		text.map(([wordDuration, word]) => {
			return (
				<span
					class="appearing-word 
					motion:safe:transition-opacity motion-safe:duration-500 motion-safe:will-change-opacity"
					data-word-duration={wordDuration}
				>
					{word}
				</span>
			);
		})
	}
</p>
<style lang="scss">
	.appearing-stage.playing {
		:where(&.has-fading-words .appearing-word) {
			opacity: 0;
		}

		&.has-finished-words .appearing-word {
			display: none;
		}

		.appearing-word {
			&.word-hide-before,
			&.word-hide-before ~ .appearing-word {
				opacity: 1;
			}

			&.last-finished-transition ~ .appearing-word {
				display: inline;
			}

			&.word-last-visible ~ .appearing-word {
				opacity: 0;
				& + .appearing-word {
					display: none;
				}
			}
		}
	}
</style>
