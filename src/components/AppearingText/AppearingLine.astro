---

import type {Tag} from './types'
import type {HTMLAttributes} from 'astro/types'

interface Props extends HTMLAttributes<"div">{
	text: string;
	tag?: Tag;
	class?: string;
	group?: string;
}
export type AppearingTextProps = Props;
const {
	tag: Element = "p",
	class: className="text-body prose",
	text,group,
	...other
} = Astro.props;
---
<!-- TODO: FIX TYPE -->
<Element
	class:list={[className]}
	data-appearing-group={group}
	{...other as any}
>
	{
		text.split(/(\s)/).map((w) => {
			return <span class="appearing-word">{w}</span>;
		})
	}
</Element>


<style lang="scss" is:global>
	.appearing-word {
		@apply motion-safe:transition-opacity motion-safe:duration-500 motion-safe:will-change-opacity;
	}
	[data-text-timings].playing {
		:where(&.has-fading-words .appearing-word) {
			opacity: 0;
		}

		&.has-finished-words .appearing-word {
			display: none;
		}

		.appearing-word {
			&.word-hide-before,
			&.word-hide-before ~ .appearing-word {
				opacity: 1;
			}

			&.last-finished-transition ~ .appearing-word {
				display: inline;
			}

			&.word-last-visible ~ .appearing-word {
				opacity: 0;
				& + .appearing-word {
					display: none;
				}
			}
		}
	}
</style>

<script>
	const stages = document.querySelectorAll<HTMLElement>("[data-text-timings]");

	play(stages[0]);

	function hasEndOfSentence(text: string) {
		return /[.!?$]/.test(text);
	}

	function play(stage: HTMLElement) {
		const start = Date.now();

		let acc = 0;
		for (const word of stage.children) {
			(word as HTMLElement).dataset.startTime = `${start + acc}`;
			acc += getWordDuration(word as HTMLElement);
		}

		const word = stage.children.item(0) as HTMLElement;
		let lastVisibleWord: HTMLElement | null = null;
		let hideBeforeWord: HTMLElement | null = null;
		let lastFinishedTransitionWord: HTMLElement | null = null;
		stage.classList.add("playing");
		stage.classList.remove("has-finished-words");
		stage.classList.remove("has-fading-words");
		playWord(word);

		function setter(
			currentValue: HTMLElement | null,
			word: HTMLElement | null,
			classToAdd: string,
			classToRemove = classToAdd
		) {
			if (currentValue === word) return word;
			currentValue?.classList.remove(classToRemove);
			word?.classList.add(classToAdd);
			return word;
		}

		function setLastVisibleWord(word: typeof lastVisibleWord) {
			lastVisibleWord = setter(lastVisibleWord, word, "word-last-visible");
		}
		function setHideBeforeWord(word: typeof hideBeforeWord) {
			hideBeforeWord = setter(hideBeforeWord, word, "word-hide-before");
		}
		function setLastFinishedTransitionWord(
			word: typeof lastFinishedTransitionWord
		) {
			stage.classList.add("has-fading-words");
			lastFinishedTransitionWord = setter(
				lastFinishedTransitionWord,
				word,
				"last-finished-transition"
			);
			stage.classList.add("has-finished-words");
		}

		function showWord(word: HTMLElement | null, delay?: number) {
			setLastVisibleWord(word);
		}

		function playWord(
			word: HTMLElement,
			lastWord: HTMLElement | null = null,
			isNewSentence?: boolean
		) {
			showWord(word);
			if (isNewSentence) setLastFinishedTransitionWord(lastWord);
			const isEndOfSentence = hasEndOfSentence(word.textContent || "");
			const nextWord = word.nextElementSibling as HTMLElement | null;

			const nextWordStamp = parseInt(nextWord?.dataset.startTime || "0");
			const timeToNextWord1 = nextWordStamp - Date.now();

			if (nextWord) {
				setTimeout(() => {
					playWord(nextWord, word, isEndOfSentence);
				}, timeToNextWord1);
			}
			if (isEndOfSentence) {
				setTimeout(() => {
					setHideBeforeWord(nextWord);
				}, timeToNextWord1 - 500);
			}
		}
	}

	function getWordDuration(word: HTMLElement): number {
		return parseFloat(word.dataset.wordDuration || "0");
	}

	function getWords(parent: HTMLElement) {
		const res = [];
		for (const child of parent.childNodes) {
			if (child.nodeType === 3) {
				res.push(child.textContent);
			}
		}
	}
</script>
